I am working on converting a businessDSL into Playwright tests. Provide separate files: visibility and functionality test files without any additional information or comments in file. I will provide you with the businessDSL. Here are the key requirements and you should consider this rules.

1. Text-based locators: 
  All locators for text-based elements (labels, buttons, headers) must use translation keys. Translations are fetched using the getTranslations function and should be integrated into the locators as `${translation.key}`. key's first letter is lowercase. 
  Use page.getByPlaceholder() for elements with placeholders.
  Use page.getByText() for labels, buttons, checkboxes, radios or any other text-based elements.
  Use page.getByLabel() for elements that are associated with a label.
  Use page.getByRole() for headings.
  FOR EXAMPLE: 
         const switchButton = await page.getByLabel(`${translation.widgetBubbleMessageText}`, { exact: true });
         const switchLabel = await page.getByText(`${translation.showSupportName}`, { exact: true });
         const saveButton = await page.getByText(`${translation.save}`, {exact: true });
         const heading = await page.getByRole('heading', { name: `${translation.settings}`, exact: true });
         const radioOption = await page.getByText(`${translation.radioText}`, {exact: true})

 
 EXAMPLE of how label and input visibility is tested. And this kind of structure can be applied for different combinations of elements.
    const label = await page.getByText(`${translation.widgetProactiveSeconds}`, { exact: true });
    const input = await page.getByLabel(`${translation.widgetProactiveSeconds}`, { exact: true });
    await expect(label).toBeVisible();
    await expect(input).toBeVisible();

When parent element is defined i.e card__body first select this and then the underlying elements i.e
      const card = page.locator('.card__body');
      const element = card.locator()


2. Test setup:
Include navigation and fetching translations in a beforeEach hook to ensure the page and translations are ready before running each test.
Base URL: https://admin.prod.buerokratt.ee. Add this before the url provided in the DSL under resource header.
Translations should be defined as:
  import { getTranslations } from '@translation/languageDetector.js';
  let translation;

And in beforeEach:
a. Each test should have annotation. So lets add in beforeEach: test.info().annotations.push({ type: 'repository', description: '<description>' });
   where instead of <description> should take value from BusinessDSL description: value. 

b. translation = await getTranslations(page);
   Translation should be after the playwright test has gone to the page to avoid security error.

c. Before checking inputs for some day, should consider WorkingHours are 24/7 switch to be turned off. 
This can be done by adding before actual input tests this part of code:
    const workingHoursSwitch = await page.getByLabel(`${translation.workingHoursAre247}`, { exact: true });
    const isChecked = await workingHoursSwitch.getAttribute('aria-checked');
    if (isChecked === 'true') {
        await workingHoursSwitch.click();
    }
    
d. Include a 3000ms timeout in the beforeEach to ensure all elements load properly.



3. Logical grouping:
Group tests using test.describe() by logical parts (e.g., headings, card body, footer).
Combine related assertions (e.g., heading and button checks) into single tests where possible.
The output should be a valid Playwright test file, ready for copy-pasting and running without further modification."

4. Exact match for similar elements:
Add { exact: true } to all locators.

5. Page Structure:
Main Heading: Check visibility of the main organizationWorkingTime heading.
Header Toggles: Group header switches into a Card Header section, including visibility checks for workingHoursAre247, considerPublicHolidays, closedOnWeekends, and sameOnAllWorkingDays.
Day-Specific Sections: For each day (Monday to Sunday), group checks under Card Body, ensuring visibility of each day’s label, toggle switch, and time inputs (startTimeInput and endTimeInput).
Footer and Notifications: Group footer elements under Card Footer to verify the save button (save), absence notification switches (sendANotificationOfAbsenceToTheClient and sendANotificationOfAbsenceToTheClientWithAContactRequest), and a text input for noCsaAvailableMessage.

6. Testing Specific UI Interactions:
Toggle Switches: Check the aria-checked state for each toggle switch before clicking to ensure toggles are only clicked if needed. For example, check the switch state for workingHoursAre247 and toggle it only if it’s set to true.
Visibility for All Elements: Confirm visibility for each element (e.g., heading, buttons, switches, inputs). Use contextual locators within specific sections like .track for day-specific elements.
Start and End Time Inputs: For each day of the week, locate startTimeInput and endTimeInput using nth() within the .track container, ensuring they are visible without labels or placeholders.

8. Parsing DSL for Element Locators:
Use nth-instance to apply .nth() for specific repeated elements, where indicated.
Apply text-based locators using translation keys (fetched via getTranslations) as ${translation.key}.
Use getByRole()

9. Functionality testing:
Test all eligble functionality and save and after return them to their original values. 
This means that you should capture the values for the inputs first and reset them at the end.

This means that if there is a save button in the DSL you should capture and click it at the end of each test, refresh the page and check if your input value is there. 
At the end of a each test it should be reset to the original value. When it comes to saving the values, wait 3 seconds after saving to ensure the values are saved.

