
"I am working on converting a businessDSL into Playwright tests. Provide the test file without any additional information. I will provide you with the businessDSL. Here are the key requirements and you should consider only those rules that are in current DSL needed. It means that if DSL does not have element that is here in the rules, then you should not consider this specific rule. In other cases should consider them:
1. Parse the DSL:
      nth-instance: Indicates the exact matching instance of a repeated element. If present, apply .nth() in the Playwright locator with the provided index.
2. Text-based locators: 
  All locators for text-based elements (labels, buttons, headers) must use translation keys. Translations are fetched using the getTranslations function and should be integrated into the locators as `${translation.key}`. key's first letter is lowercase. 
  
  Use page.getByText() for labels, buttons, or any other text-based elements.
  Use page.getByLabel() for elements that are associated with a label.
  Use page.getByRole() for headings.
  Examples: 
         const switchButton = await page.getByLabel(`${translation.widgetBubbleMessageText}`, { exact: true });
         const switchLabel = await page.getByText(`${translation.showSupportName}`, { exact: true });
         const saveButton = await page.getByText(`${translation.save}`, {exact: true });
         const heading = await page.getByRole('heading', { name: `${translation.settings}`, exact: true });

  Using getByText() and there's extra argument in the .yml file nth-matching-element the value is a locator to the n-th matching element. This is important. 
  Example:
        const label = await page.getByText(`${translation.widgetBubbleMessageText}`).nth(0);
        const label = await page.getByText(`${translation.widgetBubbleMessageText}`).nth(1);
  Otherwise:
  Example: 
    const label = await page.getByText(`${translation.widgetProactiveSeconds}`, { exact: true });
    const input = await page.getByLabel(`${translation.widgetProactiveSeconds}`, { exact: true });
    await expect(label).toBeVisible();
    await expect(input).toBeVisible();

 When parent element is defined i.e card__body first select this and then the underlying elements i.e
      const card = page.locator('.card__body');
      const element = card.locator()

3. Dropdown handling: 
   Use the following format for dropdown (select) elements FOR EXAMPLE:
   const select = await page.getByRole('combobox', { name: `${translation.widgetAnimation}` });
   When checking for the options in the dropdown (select), click on the element and then look for the options.

6. Test setup:
Include navigation and fetching translations in a beforeEach hook to ensure the page and translations are ready before running each test.
Base URL: https://admin.prod.buerokratt.ee. Add this before the url provided in the DSL under resource header.
Translations should be defined as:
  import { getTranslations } from '@translation/languageDetector.js';
  let translation;

And in beforeEach:
a. Each test should have annotation. So lets add in beforeEach: test.info().annotations.push({ type: 'repository', description: '<description>' });
   where instead of <description> should take value from BusinessDSL description: value. 

b. translation = await getTranslations(page);
   Translation should be after the playwright test has gone to the page to avoid security error.

c. Include a 3000ms timeout in the beforeEach to ensure all elements load properly.

7. Logical grouping:
Group tests using test.describe() by logical parts (e.g., headings, card body, footer).
Combine related assertions (e.g., heading and button checks) into single tests where possible.
The output should be a valid Playwright test file, ready for copy-pasting and running without further modification."

8. Exact match for similar elements:
Add { exact: true } to all locators.

9. Functionality testing.

Test all eligble functionality and save and after return them to their original values. 
This means that you should capture the values for the inputs first and reset them at the end.

This means that if there is a save button in the DSL you should capture and click it at the end of each test, refresh the page and check if your input value is there. 
At the end of a each test it should be reset to the original value. When it comes to saving the values, wait 3 seconds after saving to ensure the values are saved.

For the users functionality tests where you are testing the add user functionality, for the first name label use translation.addUserfirstAndLastName to get the translation for the label.
Add user, verify user and delete user should be sequential and in one test blcok so the test doesn't delete an existing user but rather make a new user for testing that it deletes.
and use translation.userRoles for user roles when creating the user.

To save the user use:
const saveButton = await page.getByRole('button',`${translation.addUser}`, { exact: true });

To get the first role of the adduser role selection, use this:

const roleInput = page.locator('input[role="combobox"][aria-expanded="false"]');
await roleDropdown.click();
const firstOption = await page.locator('#react-select-2-option-0');
await firstOption.click();

Use this to get the correct inserted row from the table:
const cardBody = page.locator('.card__body');
        const tableBody = cardBody.locator('tbody');
        const rows = tableBody.getByRole('row');

        let userRow = null;
        for (let i = 0; i < await rows.count(); i++) {
            const row = rows.nth(i);
            const nameCellVisible = await row.getByRole('cell', { name: 'John Doe', exact: true }).isVisible();
            const idCodeCellVisible = await row.getByRole('cell', { name: 'EE1234567890', exact: true }).isVisible();

            if (nameCellVisible && idCodeCellVisible) {
                userRow = row;
                break;
            }
        }

Steps:
DO not use card__body locator here.
Add User:
Clicks the "Add User" button.
Fills fields: name, ID code, display name, title, email, and selects a role.
the translations are: translation.addUserFirstAndLastName, translation.idCode, translation.displayName,  translation.userTitle, translation.email
Saves the user using const saveButton = await page.getByRole('button', {name:`${translation.addUser}`}, { exact: true }).click();
Waits for 3 seconds after the insertion.

Verify User:
Locates the table and iterates through its rows to find the created user by matching "John Doe" and "EE1234567890".
Ensures the user row is not null (exists).
Delete User:
Clicks the delete button for the user row.
Clicks the yes button for confirmation of deletion (its a button with yes text).
Waits for the table to refresh.
Iterates through rows to verify the user no longer exists.

To get the sorting button next to the header use for example: 
await page.getByRole('cell', { name: 'Nimi', exact: true }).getByRole('button').first();
The first click searches ascending, second click searches descending, test both

const ascendingOrder = await getColumnValues(rows, index);
const sortedAscending = [...ascendingOrder].sort((a, b) => a.localeCompare(b));

ascending sort example
      const tableHeaders = page.locator('table thead tr th');
      const headerCount = await tableHeaders.count();
      const rows = page.locator('table tbody tr');

      for (let i = 0; i < headerCount - 1; i++) {
        const header = await tableHeaders.nth(i);
        const button = await header.locator('button').nth(1);
        await button.click();
        await page.waitForTimeout(1000);

        const orderAfterClick = await getColumnValues(rows, i);
        const sortedAscending = [...orderAfterClick].sort((a, b) => a.localeCompare(b));
        await expect(orderAfterClick).toEqual(sortedAscending);
      }

      async function getColumnValues(rows, columnIndex) {
        const values = [];
        for (let i = 0; i < await rows.count(); i++) {
            const row = rows.nth(i);
            const cell = row.locator('td').nth(columnIndex); // Locate cell by column index
            const cellText = await cell.innerText(); // Fetch text content using innerText()
            values.push(cellText.trim()); // Trim extra spaces
        }
        return values;
    }

Steps:
Locates all sortable headers in the table (thead row).
Saves all the rows to check sorting correctness later.
Iterates through each header (excluding the last two, which are presumably not sortable).
Clicks the sort button twice for each header to test ascending and descending sorts. Between the sorts checks the sort order.
Verification:
Ensures headers are clickable and sorting is functional.
Confirms headers count to validate correct iteration.

To get the search button next to the header use for example:
await page.getByRole('cell', { name: 'Nimi', exact: true }).getByRole('button').nth(1);
To test searching, select the first row of the table, save the values of the columns and start searching per header search button for these values.
Identify the corresponding search button next to the header and click it.
const searchInput = await page.getByPlaceholder(`${translation.search}`);
Use the extracted value of the column to populate the search input.
Verify that the first row of the table matches the searched value.
Clear the search input and reset the search state after each iteration.
Ensure the test handles these headers:
Name
ID Code
Role
Display Name
User Title
Email

The search state should be cleared after verifying each value to isolate each test case and the searchbutton should be clicked to remove the search input.