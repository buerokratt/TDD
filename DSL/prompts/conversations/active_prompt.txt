Give me playwright tests based on the prompt and DSL.

Import these 

import { test, expect } from '@playwright/test';
import { getTranslations } from '@translation/languageDetector.js';
import {
    turnSwitchOn,
    provideData,
    takeOverFirstChat
} from 'tests/admin/landingPage/mainPage/sideBar/conversations/unanswered/helper.js';

1. Locate Elements Using Classes:
    Use the specific classes mentioned in the DSL to find and interact with elements. For example:
    vertical-tabs__group-header: Contains the header text for answered chats, which may display a dynamic count in parentheses.
    active-chat__group-wrapper Contains just chat.
    active-chat__toolbar: Contains action buttons like "Take Over."
    active-chat__side-actions: Holds various chat management buttons such as "End chat," "Ask Authentication," and "Forward to Colleague."
    active-chat__side-meta: Contains chat metadata like "Id," "End user name," "Device," and "Location."

2. "End chat" Button Visibility:
    The "End chat" button appears only when the user is set to "Present."
    Ensure that the Present/Away switch is in an active state to indicate the user is available.

3. Setup Steps in beforeEach Hook:
    After navigating to the Unanswered chats page (page.goto) and waiting for elements to load, call specific helper functions to prepare the page for testing:
    test.setTimeout(1800000);
    await page.goto('https://admin.prod.buerokratt.ee/chat/unanswered');
    test.info().annotations.push({ type: 'repository', description: 'Buerokratt-Chatbot' });
    await turnSwitchOn(page); // Activate Present switch
    await provideData(); // Provide required data
    await takeOverFirstChat(page); // Take over the first chat
    await page.goto('https://admin.prod.buerokratt.ee/chat/active');
    translation = await getTranslations(page);
    const button = page.getByRole('tab').first();
    await button.click(); 

4. Helper Functions:
    These helper functionsâ€”turnSwitchOn, provideData, and takeOverFirstChat are located in the helper.js file within the active directory. They prepare the environment and handle preconditions required for active chats tests.

5. Text that is dynamic should use regExp. For example if some text consist of static text + dynamic number then should get like this:
    await expect(pText).toHaveText(new RegExp(translation.answeredChats));

6. Check side actions buttons that they are there and whether they are enabled or disabled

7. End chat dialog opens after clicking on End chat button in active-chat__side-actions
Use this to get the radio buttons:
const element = page.getByRole('dialog);
const acceptedResponseRadio = element.getByText(`${translation.acceptedResponse}`);
const hateSpeechRadio = element.getByText(`${translation.hateSpeech}`);
const otherReasonsRadio = element.getByText(`${translation.otherReasons}`);
const responseSentRadio = element.getByText(`${translation.responseWasSentToClientEmail}`);

8. Forward to colleague dialog opens after clicking on Forward to colleague button in active-chat__side-actions

9. When getting the translations, use the full value in camelcase meaning don't skip any determiners

10. When answering chat in functionality tests use this:
const replyTextarea = page.getByPlaceholder(`${translation.reply}`);
const lastMessage = page.locator('.active-chat__message-text').last();
await expect(lastMessage).toHaveText(replyText, { timeout: 5000 });